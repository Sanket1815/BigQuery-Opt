{
  "description": "Comprehensive test queries demonstrating various BigQuery optimization scenarios with IDENTICAL results requirement",
  "version": "1.0",
  "created_date": "2024-12-19",
  "critical_requirement": "ALL optimized queries MUST return IDENTICAL results to original queries. Business logic preservation is MANDATORY.",
  
  "test_categories": {
    "basic_optimizations": {
      "description": "Basic optimization patterns that MUST preserve identical results",
      "queries": [
        {
          "id": "select_star_basic",
          "name": "SELECT * Column Pruning Test",
          "description": "Basic SELECT * that should be optimized to specific columns while returning IDENTICAL results",
          "category": "column_pruning",
          "original_query": "SELECT * FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' ORDER BY order_id LIMIT 10",
          "expected_optimizations": ["column_pruning", "partition_filtering"],
          "expected_improvement_min": 0.20,
          "business_logic": "Retrieve all order information for recent orders - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Results must be 100% identical - same rows, same columns, same values, same order"
        },
        {
          "id": "missing_partition_filter",
          "name": "Missing Partition Filter Test",
          "description": "Query without partition filter that should add partition filtering while keeping IDENTICAL results",
          "category": "partition_filtering",
          "original_query": "SELECT customer_id, total_amount FROM `{project}.{dataset}.orders` WHERE status = 'completed' ORDER BY customer_id, total_amount LIMIT 20",
          "expected_optimizations": ["partition_filtering"],
          "expected_improvement_min": 0.40,
          "business_logic": "Find completed orders with customer and amount - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must return identical customer-amount pairs in same order"
        },
        {
          "id": "count_distinct_large",
          "name": "COUNT DISTINCT Optimization Test",
          "description": "COUNT DISTINCT that can use APPROX_COUNT_DISTINCT with controlled variance",
          "category": "approximate_aggregation",
          "original_query": "SELECT DATE(order_date) as order_day, COUNT(DISTINCT customer_id) as unique_customers FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' GROUP BY DATE(order_date) ORDER BY order_day LIMIT 10",
          "expected_optimizations": ["approximate_aggregation", "partition_filtering"],
          "expected_improvement_min": 0.50,
          "business_logic": "Daily unique customer count analysis - APPROXIMATE results acceptable within 2% variance",
          "validation_notes": "APPROX_COUNT_DISTINCT may have slight variance (within 2%)",
          "allow_approximate": true,
          "max_variance_percent": 2.0
        },
        {
          "id": "full_table_scan",
          "name": "Full Table Scan Test",
          "description": "Query without WHERE clause that should add filtering while keeping IDENTICAL results",
          "category": "partition_filtering",
          "original_query": "SELECT customer_id, SUM(total_amount) as total_spent FROM `{project}.{dataset}.orders` GROUP BY customer_id ORDER BY total_spent DESC LIMIT 15",
          "expected_optimizations": ["partition_filtering"],
          "expected_improvement_min": 0.60,
          "business_logic": "Customer total spending analysis - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All customer spending totals must be exactly identical"
        }
      ]
    },
    
    "join_optimizations": {
      "description": "JOIN optimization scenarios that MUST preserve identical results",
      "queries": [
        {
          "id": "inefficient_join_order",
          "name": "Inefficient JOIN Order Test",
          "description": "JOINs in suboptimal order that should be reordered while returning IDENTICAL results",
          "category": "join_reordering",
          "original_query": "SELECT c.customer_name, o.order_id, p.product_name FROM `{project}.{dataset}.orders` o JOIN `{project}.{dataset}.customers` c ON o.customer_id = c.customer_id JOIN `{project}.{dataset}.products` p ON o.product_id = p.product_id WHERE o.order_date >= '2024-06-01' ORDER BY o.order_id LIMIT 12",
          "expected_optimizations": ["join_reordering", "partition_filtering"],
          "expected_improvement_min": 0.30,
          "business_logic": "Customer-product-order details - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All JOIN results must be identical regardless of JOIN order"
        },
        {
          "id": "implicit_cross_join",
          "name": "Implicit Cross JOIN Test",
          "description": "Implicit cross JOIN that should be converted to explicit JOIN while keeping IDENTICAL results",
          "category": "join_reordering",
          "original_query": "SELECT c.customer_name, o.total_amount FROM `{project}.{dataset}.customers` c, `{project}.{dataset}.orders` o WHERE c.customer_id = o.customer_id AND o.order_date >= '2024-06-01' ORDER BY c.customer_id, o.order_id LIMIT 10",
          "expected_optimizations": ["join_reordering", "partition_filtering"],
          "expected_improvement_min": 0.25,
          "business_logic": "Customer orders using implicit JOIN - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must return identical customer-order combinations"
        },
        {
          "id": "multiple_left_joins",
          "name": "Multiple LEFT JOINs Test",
          "description": "Multiple LEFT JOINs that should preserve NULL values and return IDENTICAL results",
          "category": "join_reordering",
          "original_query": "SELECT c.customer_name, c.region, o.order_id, o.total_amount FROM `{project}.{dataset}.customers` c LEFT JOIN `{project}.{dataset}.orders` o ON c.customer_id = o.customer_id WHERE c.customer_tier IN ('Premium', 'Gold') AND (o.order_date >= '2024-06-01' OR o.order_date IS NULL) ORDER BY c.customer_id, o.order_id LIMIT 20",
          "expected_optimizations": ["partition_filtering"],
          "expected_improvement_min": 0.20,
          "business_logic": "Premium/Gold customers with their orders (including customers with no orders) - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must preserve LEFT JOIN semantics - customers without orders must still appear with NULL values"
        }
      ]
    },
    
    "subquery_optimizations": {
      "description": "Subquery conversion scenarios that MUST preserve identical results",
      "queries": [
        {
          "id": "correlated_exists_subquery",
          "name": "Correlated EXISTS Subquery Test",
          "description": "EXISTS subquery that should convert to JOIN while returning IDENTICAL results",
          "category": "subquery_to_join",
          "original_query": "SELECT customer_id, customer_name FROM `{project}.{dataset}.customers` c WHERE EXISTS (SELECT 1 FROM `{project}.{dataset}.orders` o WHERE o.customer_id = c.customer_id AND o.order_date >= '2024-06-01' AND o.status = 'completed') ORDER BY customer_id LIMIT 15",
          "expected_optimizations": ["subquery_to_join", "partition_filtering"],
          "expected_improvement_min": 0.35,
          "business_logic": "Customers who have completed orders since June 2024 - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must return identical customer list in same order"
        },
        {
          "id": "nested_in_subqueries",
          "name": "Nested IN Subqueries Test",
          "description": "Nested IN subqueries that should be flattened while returning IDENTICAL results",
          "category": "subquery_to_join",
          "original_query": "SELECT customer_name FROM `{project}.{dataset}.customers` WHERE customer_id IN (SELECT customer_id FROM `{project}.{dataset}.orders` WHERE order_id IN (SELECT order_id FROM `{project}.{dataset}.order_items` WHERE quantity > 3) AND order_date >= '2024-06-01') ORDER BY customer_name LIMIT 10",
          "expected_optimizations": ["subquery_to_join", "partition_filtering"],
          "expected_improvement_min": 0.45,
          "business_logic": "Customers with high-quantity orders since June 2024 - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must return identical customer names in same order"
        },
        {
          "id": "not_exists_subquery",
          "name": "NOT EXISTS Subquery Test",
          "description": "NOT EXISTS subquery for finding customers without recent orders - IDENTICAL results required",
          "category": "subquery_to_join",
          "original_query": "SELECT customer_id, customer_name FROM `{project}.{dataset}.customers` c WHERE NOT EXISTS (SELECT 1 FROM `{project}.{dataset}.orders` o WHERE o.customer_id = c.customer_id AND o.order_date >= '2024-06-01') ORDER BY customer_id LIMIT 10",
          "expected_optimizations": ["subquery_to_join"],
          "expected_improvement_min": 0.25,
          "business_logic": "Customers who haven't ordered since June 2024 - RESULTS MUST BE IDENTICAL",
          "validation_notes": "Must return identical list of inactive customers"
        }
      ]
    },
    
    "window_function_optimizations": {
      "description": "Window function optimization scenarios that MUST preserve identical results",
      "queries": [
        {
          "id": "inefficient_window_functions",
          "name": "Inefficient Window Functions Test",
          "description": "Window functions without proper partitioning that should be optimized while returning IDENTICAL results",
          "category": "window_optimization",
          "original_query": "SELECT customer_id, order_date, total_amount, ROW_NUMBER() OVER (ORDER BY total_amount DESC) as amount_rank, RANK() OVER (ORDER BY order_date) as date_rank FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' ORDER BY amount_rank LIMIT 10",
          "expected_optimizations": ["window_optimization", "partition_filtering"],
          "expected_improvement_min": 0.20,
          "business_logic": "Order ranking by amount and date - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All rankings must be exactly identical"
        },
        {
          "id": "customer_analytics_window",
          "name": "Customer Analytics Window Functions Test",
          "description": "Customer analytics using window functions that should be optimized while keeping IDENTICAL results",
          "category": "window_optimization",
          "original_query": "SELECT customer_id, order_date, total_amount, SUM(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date ROWS UNBOUNDED PRECEDING) as running_total, LAG(total_amount) OVER (PARTITION BY customer_id ORDER BY order_date) as prev_order_amount FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' ORDER BY customer_id, order_date LIMIT 20",
          "expected_optimizations": ["partition_filtering"],
          "expected_improvement_min": 0.25,
          "business_logic": "Customer running totals and previous order analysis - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All running totals and LAG values must be exactly identical"
        },
        {
          "id": "ranking_without_partition",
          "name": "Ranking Without Proper Partitioning Test",
          "description": "Ranking query that should optimize window partitioning while keeping IDENTICAL results",
          "category": "window_optimization",
          "original_query": "SELECT customer_id, order_id, total_amount, DENSE_RANK() OVER (ORDER BY total_amount DESC) as amount_dense_rank FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' AND status = 'completed' ORDER BY amount_dense_rank, order_id LIMIT 15",
          "expected_optimizations": ["window_optimization", "partition_filtering"],
          "expected_improvement_min": 0.15,
          "business_logic": "Dense ranking of completed orders by amount - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All dense rank values must be exactly identical"
        }
      ]
    },
    
    "aggregation_optimizations": {
      "description": "Aggregation optimization scenarios that MUST preserve identical results",
      "queries": [
        {
          "id": "heavy_aggregation_query",
          "name": "Heavy Aggregation Query Test",
          "description": "Heavy aggregation that should use partition filtering and possibly approximate functions while keeping IDENTICAL results",
          "category": "aggregation_optimization",
          "original_query": "SELECT c.region, COUNT(*) as total_orders, SUM(o.total_amount) as total_revenue, AVG(o.total_amount) as avg_order_value, COUNT(DISTINCT o.customer_id) as unique_customers FROM `{project}.{dataset}.orders` o JOIN `{project}.{dataset}.customers` c ON o.customer_id = c.customer_id WHERE o.order_date >= '2024-01-01' GROUP BY c.region ORDER BY total_revenue DESC",
          "expected_optimizations": ["partition_filtering", "approximate_aggregation"],
          "expected_improvement_min": 0.40,
          "business_logic": "Regional sales analysis with customer metrics - RESULTS MUST BE IDENTICAL (except APPROX functions)",
          "validation_notes": "All aggregated values must be identical except COUNT(DISTINCT) if converted to APPROX",
          "allow_approximate": true,
          "max_variance_percent": 2.0
        },
        {
          "id": "time_series_aggregation",
          "name": "Time Series Aggregation Test",
          "description": "Time-based aggregation that should optimize date filtering while keeping IDENTICAL results",
          "category": "partition_filtering",
          "original_query": "SELECT DATE(order_date) as order_day, COUNT(*) as daily_orders, SUM(total_amount) as daily_revenue, MIN(total_amount) as min_order, MAX(total_amount) as max_order FROM `{project}.{dataset}.orders` WHERE order_date BETWEEN '2024-06-01' AND '2024-06-30' GROUP BY DATE(order_date) ORDER BY order_day",
          "expected_optimizations": ["partition_filtering"],
          "expected_improvement_min": 0.35,
          "business_logic": "Daily sales statistics for June 2024 - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All daily statistics must be exactly identical"
        },
        {
          "id": "multiple_count_distinct",
          "name": "Multiple COUNT DISTINCT Test",
          "description": "Multiple COUNT DISTINCT functions that should use approximate aggregation while keeping controlled variance",
          "category": "approximate_aggregation",
          "original_query": "SELECT p.category, COUNT(DISTINCT o.customer_id) as unique_customers, COUNT(DISTINCT o.order_id) as unique_orders FROM `{project}.{dataset}.orders` o JOIN `{project}.{dataset}.products` p ON o.product_id = p.product_id WHERE o.order_date >= '2024-06-01' GROUP BY p.category ORDER BY unique_customers DESC LIMIT 5",
          "expected_optimizations": ["approximate_aggregation", "partition_filtering"],
          "expected_improvement_min": 0.50,
          "business_logic": "Product category customer and order analysis - APPROXIMATE results acceptable within 2% variance",
          "validation_notes": "APPROX functions may have slight variance (within 2%)",
          "allow_approximate": true,
          "max_variance_percent": 2.0
        }
      ]
    },
    
    "complex_scenarios": {
      "description": "Complex multi-optimization scenarios that MUST preserve identical results",
      "queries": [
        {
          "id": "customer_lifetime_value",
          "name": "Customer Lifetime Value Analysis Test",
          "description": "Complex customer analysis that should apply multiple optimizations while keeping IDENTICAL results",
          "category": "complex_multi_optimization",
          "original_query": "SELECT c.customer_id, c.customer_name, c.customer_tier, COUNT(o.order_id) as total_orders, SUM(o.total_amount) as lifetime_value, AVG(o.total_amount) as avg_order_value, MAX(o.order_date) as last_order_date FROM `{project}.{dataset}.customers` c LEFT JOIN `{project}.{dataset}.orders` o ON c.customer_id = o.customer_id WHERE c.signup_date >= '2020-01-01' AND (o.order_date >= '2024-01-01' OR o.order_date IS NULL) GROUP BY c.customer_id, c.customer_name, c.customer_tier HAVING COUNT(o.order_id) > 0 ORDER BY lifetime_value DESC LIMIT 20",
          "expected_optimizations": ["partition_filtering", "join_reordering"],
          "expected_improvement_min": 0.35,
          "business_logic": "Customer lifetime value analysis for customers since 2020 with orders in 2024 - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All customer metrics must be exactly identical"
        },
        {
          "id": "product_performance_analysis",
          "name": "Product Performance Analysis Test",
          "description": "Product performance analysis with multiple JOINs and aggregations that should be optimized while keeping IDENTICAL results",
          "category": "complex_multi_optimization",
          "original_query": "SELECT p.product_name, p.category, COUNT(oi.item_id) as items_sold, SUM(oi.quantity) as total_quantity, SUM(oi.quantity * oi.unit_price) as total_revenue, COUNT(DISTINCT o.customer_id) as unique_buyers FROM `{project}.{dataset}.products` p JOIN `{project}.{dataset}.order_items` oi ON p.product_id = oi.product_id JOIN `{project}.{dataset}.orders` o ON oi.order_id = o.order_id WHERE o.order_date >= '2024-06-01' AND o.status = 'completed' GROUP BY p.product_id, p.product_name, p.category ORDER BY total_revenue DESC LIMIT 10",
          "expected_optimizations": ["join_reordering", "partition_filtering", "approximate_aggregation"],
          "expected_improvement_min": 0.40,
          "business_logic": "Product sales performance analysis - RESULTS MUST BE IDENTICAL (except APPROX functions)",
          "validation_notes": "All product metrics must be identical except COUNT(DISTINCT) if converted to APPROX",
          "allow_approximate": true,
          "max_variance_percent": 2.0
        },
        {
          "id": "customer_cohort_analysis",
          "name": "Customer Cohort Analysis Test",
          "description": "Customer cohort analysis with window functions and aggregations that should be optimized while keeping IDENTICAL results",
          "category": "complex_multi_optimization",
          "original_query": "SELECT customer_tier, signup_month, COUNT(*) as customers_in_cohort, SUM(total_orders) as cohort_total_orders, AVG(total_orders) as avg_orders_per_customer FROM (SELECT c.customer_tier, DATE_TRUNC(c.signup_date, MONTH) as signup_month, COUNT(o.order_id) as total_orders FROM `{project}.{dataset}.customers` c LEFT JOIN `{project}.{dataset}.orders` o ON c.customer_id = o.customer_id WHERE c.signup_date >= '2020-01-01' AND (o.order_date >= '2024-01-01' OR o.order_date IS NULL) GROUP BY c.customer_id, c.customer_tier, DATE_TRUNC(c.signup_date, MONTH)) GROUP BY customer_tier, signup_month ORDER BY customer_tier, signup_month LIMIT 25",
          "expected_optimizations": ["subquery_to_join", "partition_filtering"],
          "expected_improvement_min": 0.30,
          "business_logic": "Customer cohort analysis by signup month and tier - RESULTS MUST BE IDENTICAL",
          "validation_notes": "All cohort metrics must be exactly identical"
        }
      ]
    }
  },
  
  "validation_settings": {
    "default_sample_size": 1000,
    "performance_measurement_iterations": 3,
    "min_improvement_threshold": 0.15,
    "max_execution_time_seconds": 300,
    "result_comparison_tolerance": {
      "numeric_precision": 10,
      "percentage_variance_allowed": 0.0,
      "approximate_function_variance": 2.0
    }
  },
  
  "critical_requirements": [
    "ALL optimized queries MUST return IDENTICAL results to original queries",
    "Business logic preservation is MANDATORY - no exceptions",
    "Any difference in results means the optimization FAILED",
    "Approximate functions may have controlled variance within specified limits",
    "Performance improvements are secondary to result accuracy",
    "The system must ALWAYS show both original and optimized query results",
    "Validation must be comprehensive and clearly report any differences",
    "Only add _PARTITIONDATE filters for tables that are actually partitioned",
    "Check table metadata before adding partition filters to avoid errors"
  ],
  
  "test_execution_notes": [
    "Every test query MUST pass result identity validation",
    "The system will show actual results from both queries side-by-side",
    "Any optimization that changes results will be marked as FAILED",
    "Approximate functions are clearly marked and have variance tolerance",
    "All queries use {project} and {dataset} placeholders for flexibility",
    "Partition filtering should only be added to partitioned tables",
    "Business logic descriptions explain what each query should accomplish",
    "UI will display both original and optimized query results for transparency"
  ]
}