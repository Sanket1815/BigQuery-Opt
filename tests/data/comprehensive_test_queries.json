{
  "description": "Comprehensive test queries for BigQuery optimization with IDENTICAL results requirement",
  "version": "1.0",
  "created_date": "2024-12-19",
  "critical_requirement": "ALL optimized queries MUST return IDENTICAL results to original queries",
  
  "dynamic_test_queries": [
    {
      "id": "select_star_basic",
      "name": "SELECT * Column Pruning Test",
      "description": "Basic SELECT * that should be optimized to specific columns",
      "category": "column_pruning",
      "original_query": "SELECT * FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' ORDER BY order_id LIMIT 10",
      "expected_optimizations": ["column_pruning"],
      "business_logic": "Retrieve all order information for recent orders",
      "expected_improvement_min": 0.20
    },
    {
      "id": "subquery_to_join_exists",
      "name": "EXISTS Subquery to JOIN Conversion",
      "description": "Convert EXISTS subquery to INNER JOIN for better performance",
      "category": "subquery_to_join",
      "original_query": "SELECT customer_id, customer_name FROM `{project}.{dataset}.customers` c WHERE EXISTS (SELECT 1 FROM `{project}.{dataset}.orders` o WHERE o.customer_id = c.customer_id AND o.order_date >= '2024-06-01')",
      "expected_optimizations": ["subquery_to_join"],
      "business_logic": "Find customers who have placed orders since June 2024",
      "expected_improvement_min": 0.35
    },
    {
      "id": "subquery_to_join_in",
      "name": "IN Subquery to JOIN Conversion", 
      "description": "Convert IN subquery to INNER JOIN for better performance",
      "category": "subquery_to_join",
      "original_query": "SELECT customer_name FROM `{project}.{dataset}.customers` WHERE customer_id IN (SELECT customer_id FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' AND status = 'completed')",
      "expected_optimizations": ["subquery_to_join"],
      "business_logic": "Find customers who have completed orders since June 2024",
      "expected_improvement_min": 0.30
    },
    {
      "id": "join_reordering",
      "name": "JOIN Order Optimization",
      "description": "Reorder JOINs to place smaller tables first",
      "category": "join_reordering", 
      "original_query": "SELECT c.customer_name, o.order_id, p.product_name FROM `{project}.{dataset}.orders` o JOIN `{project}.{dataset}.customers` c ON o.customer_id = c.customer_id JOIN `{project}.{dataset}.products` p ON o.product_id = p.product_id WHERE o.order_date >= '2024-06-01'",
      "expected_optimizations": ["join_reordering"],
      "business_logic": "Get customer and product details for recent orders",
      "expected_improvement_min": 0.25
    },
    {
      "id": "count_distinct_to_approx",
      "name": "COUNT DISTINCT to Approximate Aggregation",
      "description": "Replace COUNT DISTINCT with APPROX_COUNT_DISTINCT for large datasets",
      "category": "approximate_aggregation",
      "original_query": "SELECT DATE(order_date) as order_day, COUNT(DISTINCT customer_id) as unique_customers FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' GROUP BY DATE(order_date)",
      "expected_optimizations": ["approximate_aggregation"],
      "business_logic": "Daily unique customer count analysis",
      "expected_improvement_min": 0.50,
      "allow_approximate": true,
      "max_variance_percent": 2.0
    },
    {
      "id": "window_function_optimization",
      "name": "Window Function Optimization",
      "description": "Optimize window functions with better partitioning",
      "category": "window_optimization",
      "original_query": "SELECT customer_id, order_date, total_amount, ROW_NUMBER() OVER (ORDER BY total_amount DESC) as rank FROM `{project}.{dataset}.orders` WHERE order_date >= '2024-06-01' ORDER BY rank LIMIT 10",
      "expected_optimizations": ["window_optimization"],
      "business_logic": "Rank orders by amount for recent orders",
      "expected_improvement_min": 0.20
    },
    {
      "id": "correlated_subquery_to_window",
      "name": "Correlated Subquery to Window Function",
      "description": "Convert correlated subquery to window function",
      "category": "subquery_to_window",
      "original_query": "SELECT customer_id, order_date, total_amount, (SELECT COUNT(*) FROM `{project}.{dataset}.orders` o2 WHERE o2.customer_id = o1.customer_id AND o2.order_date <= o1.order_date) as order_sequence FROM `{project}.{dataset}.orders` o1 WHERE order_date >= '2024-06-01'",
      "expected_optimizations": ["subquery_to_window"],
      "business_logic": "Calculate order sequence number for each customer",
      "expected_improvement_min": 0.40
    },
    {
      "id": "clustering_optimization",
      "name": "Clustering Key Optimization",
      "description": "Optimize WHERE clauses to use clustering keys",
      "category": "clustering_optimization",
      "original_query": "SELECT * FROM `{project}.{dataset}.orders` WHERE status = 'completed' AND total_amount > 100 ORDER BY order_date LIMIT 20",
      "expected_optimizations": ["clustering_optimization", "column_pruning"],
      "business_logic": "Find high-value completed orders",
      "expected_improvement_min": 0.25
    },
    {
      "id": "predicate_pushdown",
      "name": "Predicate Pushdown Optimization",
      "description": "Move filters closer to data sources",
      "category": "predicate_pushdown",
      "original_query": "SELECT c.customer_name, o.total_amount FROM (SELECT * FROM `{project}.{dataset}.customers`) c JOIN (SELECT * FROM `{project}.{dataset}.orders`) o ON c.customer_id = o.customer_id WHERE c.customer_tier = 'Premium' AND o.order_date >= '2024-06-01'",
      "expected_optimizations": ["predicate_pushdown", "column_pruning"],
      "business_logic": "Get premium customer orders with predicate pushdown",
      "expected_improvement_min": 0.35
    },
    {
      "id": "complex_aggregation",
      "name": "Complex Aggregation Optimization",
      "description": "Optimize complex aggregation with multiple functions",
      "category": "aggregation_optimization",
      "original_query": "SELECT c.region, COUNT(*) as total_orders, SUM(o.total_amount) as total_revenue, AVG(o.total_amount) as avg_order, COUNT(DISTINCT o.customer_id) as unique_customers FROM `{project}.{dataset}.orders` o JOIN `{project}.{dataset}.customers` c ON o.customer_id = c.customer_id WHERE o.order_date >= '2024-01-01' GROUP BY c.region",
      "expected_optimizations": ["approximate_aggregation", "join_reordering"],
      "business_logic": "Regional sales analysis with customer metrics",
      "expected_improvement_min": 0.40,
      "allow_approximate": true,
      "max_variance_percent": 2.0
    },
    {
      "id": "nested_subqueries",
      "name": "Nested Subqueries Flattening",
      "description": "Flatten deeply nested subqueries to JOINs",
      "category": "subquery_flattening",
      "original_query": "SELECT customer_name FROM `{project}.{dataset}.customers` WHERE customer_id IN (SELECT customer_id FROM `{project}.{dataset}.orders` WHERE order_id IN (SELECT order_id FROM `{project}.{dataset}.order_items` WHERE quantity > 3))",
      "expected_optimizations": ["subquery_to_join"],
      "business_logic": "Find customers with high-quantity orders",
      "expected_improvement_min": 0.45
    },
    {
      "id": "materialized_view_candidate",
      "name": "Materialized View Recommendation",
      "description": "Identify queries that would benefit from materialized views",
      "category": "materialized_view",
      "original_query": "SELECT p.category, COUNT(*) as order_count, SUM(oi.quantity * oi.unit_price) as total_revenue FROM `{project}.{dataset}.products` p JOIN `{project}.{dataset}.order_items` oi ON p.product_id = oi.product_id JOIN `{project}.{dataset}.orders` o ON oi.order_id = o.order_id WHERE o.order_date >= '2024-01-01' GROUP BY p.category",
      "expected_optimizations": ["materialized_view_suggestion", "join_reordering"],
      "business_logic": "Product category performance analysis",
      "expected_improvement_min": 0.30
    },
    {
      "id": "implicit_cross_join",
      "name": "Implicit Cross JOIN Conversion",
      "description": "Convert implicit cross JOINs to explicit JOINs",
      "category": "join_conversion",
      "original_query": "SELECT c.customer_name, o.total_amount FROM `{project}.{dataset}.customers` c, `{project}.{dataset}.orders` o WHERE c.customer_id = o.customer_id AND o.order_date >= '2024-06-01'",
      "expected_optimizations": ["join_conversion"],
      "business_logic": "Customer orders using implicit JOIN syntax",
      "expected_improvement_min": 0.20
    },
    {
      "id": "multiple_aggregations",
      "name": "Multiple Aggregation Functions Optimization",
      "description": "Optimize queries with multiple aggregation functions",
      "category": "aggregation_optimization",
      "original_query": "SELECT customer_tier, COUNT(*) as customers, SUM(total_spent) as revenue, AVG(total_spent) as avg_spent, MIN(total_spent) as min_spent, MAX(total_spent) as max_spent, COUNT(DISTINCT region) as regions FROM (SELECT c.customer_tier, c.region, SUM(o.total_amount) as total_spent FROM `{project}.{dataset}.customers` c LEFT JOIN `{project}.{dataset}.orders` o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.customer_tier, c.region) GROUP BY customer_tier",
      "expected_optimizations": ["approximate_aggregation", "subquery_optimization"],
      "business_logic": "Customer tier analysis with spending metrics",
      "expected_improvement_min": 0.35,
      "allow_approximate": true,
      "max_variance_percent": 2.0
    },
    {
      "id": "time_series_analysis",
      "name": "Time Series Analysis Optimization",
      "description": "Optimize time-based aggregation queries",
      "category": "time_series_optimization",
      "original_query": "SELECT DATE_TRUNC(order_date, WEEK) as week, COUNT(*) as weekly_orders, SUM(total_amount) as weekly_revenue, COUNT(DISTINCT customer_id) as weekly_customers FROM `{project}.{dataset}.orders` WHERE order_date BETWEEN '2024-01-01' AND '2024-12-31' GROUP BY DATE_TRUNC(order_date, WEEK) ORDER BY week",
      "expected_optimizations": ["approximate_aggregation"],
      "business_logic": "Weekly sales trend analysis",
      "expected_improvement_min": 0.30,
      "allow_approximate": true,
      "max_variance_percent": 2.0
    }
  ],
  
  "optimization_patterns": {
    "subquery_to_join": {
      "description": "Convert subqueries to JOINs where appropriate",
      "examples": [
        "EXISTS -> INNER JOIN",
        "IN (SELECT) -> INNER JOIN", 
        "NOT EXISTS -> LEFT JOIN with IS NULL"
      ]
    },
    "partition_filtering": {
      "description": "Add partition filters to reduce data scanned",
      "examples": [
        "Add _PARTITIONDATE >= 'date' for date-partitioned tables",
        "Use partition pseudo-columns for filtering"
      ]
    },
    "join_reordering": {
      "description": "Optimize JOIN order based on table sizes",
      "examples": [
        "Place smaller tables first in JOIN chain",
        "Move more selective conditions earlier"
      ]
    },
    "approximate_aggregation": {
      "description": "Use approximate aggregation functions where applicable",
      "examples": [
        "COUNT(DISTINCT) -> APPROX_COUNT_DISTINCT()",
        "Use HLL functions for very large datasets"
      ]
    },
    "clustering_optimization": {
      "description": "Implement clustering recommendations",
      "examples": [
        "Use clustering keys in WHERE clauses",
        "Optimize filter conditions for clustering"
      ]
    },
    "column_pruning": {
      "description": "Remove unnecessary columns from SELECT statements",
      "examples": [
        "SELECT * -> SELECT specific_columns",
        "Remove unused columns from intermediate results"
      ]
    },
    "subquery_to_window": {
      "description": "Convert correlated subqueries to window functions",
      "examples": [
        "Correlated COUNT -> ROW_NUMBER() OVER()",
        "Running totals using window functions"
      ]
    }
  },
  
  "validation_requirements": {
    "results_must_be_identical": true,
    "zero_tolerance_for_differences": true,
    "business_logic_preservation_mandatory": true,
    "approximate_functions_allowed_with_variance": true,
    "max_variance_percent_for_approx": 2.0,
    "always_show_both_query_results": true,
    "validation_failure_stops_optimization": true
  },
  
  "test_execution_guidelines": [
    "Users can input ANY SQL query dynamically",
    "System must analyze and optimize any valid BigQuery SQL",
    "Results must ALWAYS be identical (except controlled approximate variance)",
    "Both original and optimized query results must be shown",
    "Clear validation status must be displayed",
    "Optimization patterns should be applied dynamically based on query structure",
    "No hardcoded optimizations - all should be AI-driven based on patterns"
  ]
}